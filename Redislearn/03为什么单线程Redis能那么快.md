<!--
 * @Author: zzzzztw
 * @Date: 2023-03-04 10:13:44
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-03-04 12:33:45
 * @FilePath: /cpptest/Redislearn/03为什么单线程Redis能那么快.md
-->
# 高性能IO模型：为什么单线程Redis能那么快？
首先一个重要事实，说Redis是单线程通常指的时Redis的网络IO和键值对读写是一个线程来完成的，这也是Redis对外提供键值对存储服务的主要流程，但redis的其他功能，如持久化，异步删除和集群数据同步等是采用额外的线程执行的。
## Redis为什么采用单线程
1. 多线程的开销：一味的堆积多线程不能达到始终提高吞吐率的效果，如果不能良好的设计整体架构由于资源间的竞争最终将退化为单线程串行的效果，此外还增加了线程上下文切换的开销。
2. redis单线程为什么快：两方面，一方面redis采用了多种高效的数据结构复合存储数据，例如哈希表和跳表，另一方面redis采用了多路复用机制，能并发的处理多个网络io请求。

## 基本io模型和阻塞点
以Get请求为例，redis为了处理get请求，需要监听客户端(listen)，和客户端建立连接(accept)，从socket中读取请求(recv)，解析客户端请求(parse)，根据请求返回get(GET)，最后再把结果发送给客户端(send)，如下图：
<center>

![](./img/03(1).png)
</center>
但在网络io中有很多潜在的阻塞点，如accept(),recv()。当redis监听到有链接请求，但未能成功连接，就会一直阻塞到accept()函数，无法和其他客户端建立连接，同样，recv()函数也是，读取数据时，一直没能收到将阻塞。   

## 非阻塞模型
1. Socket 网络模型的非阻塞模式设置，主要体现在三个关键的函数调用上，socket,listen,accept.,socket生成一个主动套接字，调用listen转变为监听套接字，此时可以监听来自客户端的连接请求，最后调用accept方法接受到达客户端连接，并返回已连接套接字。
2. 非阻塞模式：基于多路复用的高性能I/O模型，如epoll,内核会一直监听以上这些套接字的连接请求或数据请求，一旦有请求到达就会交给redis线程处理，实现了单线程处理多个io流的效果。为了请求到达时能通知到redis线程，epoll提供了基于事件的回调机制，针对不同事件的发生触发不同的回调处理函数。
3. 回调函数工作机制：epoll检测到fd上有事件到达，就会触发相应的事件，这些事件会放进一个就绪队列，redis线程对这个事件队列进行不断的处理，这样redis就无需轮询是否有事件发生，对队列中事件处理时，会调用相应的处理函数，实现了基于事件的回调。  
如：  
以连接请求和读数据请求为例，这两个请求分别对应 Accept 事件和 Read 事件，Redis 分别对这两个事件注册 accept 和 get 回调函数。当 Linux 内核监听到有连接请求或读数据请求时，就会触发 Accept 事件和 Read 事件，此时，内核就会回调 Redis 相应的 accept 和 get 函数进行处理。

## 潜在的性能瓶颈
1、任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种：  
	a、操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；  
	b、使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；  
	c、大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；  
	d、淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；
	e、AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；  
	f、主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；   
     
2、并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。

针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。

针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。